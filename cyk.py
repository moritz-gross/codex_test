from __future__ import annotations

from collections import defaultdict
from typing import Iterable


def _build_maps(
    grammar: dict[str, list[tuple[str, str] | str]],
) -> tuple[
    dict[str, set[str]],
    dict[tuple[str, str], set[str]],
    set[str],
]:
    term_map: dict[str, set[str]] = defaultdict(set)
    pair_map: dict[tuple[str, str], set[str]] = defaultdict(set)
    epsilon_set: set[str] = set()

    for lhs, productions in grammar.items():
        for prod in productions:
            if isinstance(prod, str):
                if prod == "":
                    epsilon_set.add(lhs)
                else:
                    term_map[prod].add(lhs)
            else:
                if len(prod) != 2:
                    raise ValueError(f"Non-terminal production must be length 2: {lhs} -> {prod}")
                pair_map[(prod[0], prod[1])].add(lhs)

    return term_map, pair_map, epsilon_set


def cyk_table(
    input_data: Iterable[str] | str,
    grammar: dict[str, list[tuple[str, str] | str]],
    start_symbol: str = "S",
) -> tuple[list[str], list[list[set[str]]], bool, dict]:
    """
    Return (tokens, table, accepted, derivations) for the CYK algorithm.

    input_data can be an iterable of tokens or a string (treated as characters).
    Grammar format: {NonTerminal: [("A", "B"), "a", ...]}.
    Use "" for an epsilon production (only supported for empty input).

    derivations is a dict mapping (i, j, nonterminal) to its source:
        {(i, j, 'A'): {'left_cell': (i, k), 'right_cell': (k+1, j),
                       'left_symbol': 'B', 'right_symbol': 'C'}}
    """
    tokens = list(input_data) if not isinstance(input_data, str) else list(input_data)
    term_map, pair_map, epsilon_set = _build_maps(grammar)

    n = len(tokens)
    if n == 0:
        return tokens, [], start_symbol in epsilon_set, {}

    table: list[list[set[str]]] = [[set() for _ in range(n)] for _ in range(n)]
    derivations: dict[tuple[int, int, str], dict] = {}

    for i, token in enumerate(tokens):
        nonterminals = term_map.get(token, set())
        for nt in nonterminals:
            # Store terminal derivations: nonterminal came from this token
            derivations[(i, i, nt)] = {
                'terminal': token,
                'position': i
            }
        table[i][i].update(nonterminals)

    for span in range(2, n + 1):
        for i in range(n - span + 1):
            j = i + span - 1
            cell = table[i][j]
            for k in range(i, j):
                left = table[i][k]
                right = table[k + 1][j]
                for b in left:
                    for c in right:
                        new_nonterminals = pair_map.get((b, c), set())
                        for nt in new_nonterminals:
                            # Only store the first derivation found for each nonterminal
                            if nt not in cell:
                                derivations[(i, j, nt)] = {
                                    'left_cell': (i, k),
                                    'right_cell': (k + 1, j),
                                    'left_symbol': b,
                                    'right_symbol': c
                                }
                        cell.update(new_nonterminals)

    return tokens, table, start_symbol in table[0][n - 1], derivations


def cyk_accepts(
    input_data: Iterable[str] | str,
    grammar: dict[str, list[tuple[str, str] | str]],
    start_symbol: str = "S",
) -> bool:
    """
    Determine whether input_data is generated by a CNF grammar using CYK.

    input_data can be an iterable of tokens or a string (treated as characters).
    Grammar format: {NonTerminal: [("A", "B"), "a", ...]}.
    Use "" for an epsilon production (only supported for empty input).
    """
    _, _, accepted, _ = cyk_table(input_data, grammar, start_symbol)
    return accepted
